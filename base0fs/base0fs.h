/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/base0fs.h
 */

#ifndef __BASE0FS_H_
#define __BASE0FS_H_

#ifdef __KERNEL__

#include "kernel_config.h"

/*
 * STRUCTURES:
 */


/* Turn this on to include code that counts writes and writes in the middle */
/* #undef FIST_COUNT_WRITES */

/* fist file systems superblock magic */
#define BASE0FS_SUPER_MAGIC 0xf15f


/* base0fs inode data in memory */
struct base0fs_inode_info {
	inode_t *wii_inode;
        struct inode vfs_inode;
};

static inline struct base0fs_inode_info *BASE0FS_I(struct inode *inode)
{
        return container_of(inode, struct base0fs_inode_info, vfs_inode);
}

/* base0fs dentry data in memory */
struct base0fs_dentry_info {
	struct dentry *wdi_dentry;
	struct vfsmount *wdi_mnt;
};


/* base0fs super-block data in memory */
struct base0fs_sb_info {
	super_block_t *wsi_sb;
	;
};

/* file private data. */
struct base0fs_file_info {
	struct file *wfi_file;
};

/*
 * MACROS:
 */

// File TO Private Data
#define FILE_TO_PRIVATE(file) ((struct base0fs_file_info *)((file)->private_data))
#define FILE_TO_PRIVATE_SM(file) ((file)->private_data)
// File TO lower File
#define FILE_TO_LOWER(file) ((FILE_TO_PRIVATE(file))->wfi_file)
// Inode TO Private Data
#define INODE_TO_PRIVATE(ino) (container_of(ino, struct base0fs_inode_info, vfs_inode))
#define INODE_TO_PRIVATE_SM(ino) ((void*)container_of(ino, struct base0fs_inode_info, vfs_inode))
// Inode TO lower Inode
#define INODE_TO_LOWER(ino) (INODE_TO_PRIVATE(ino)->wii_inode)
#define vnode2lower INODE_TO_LOWER
// Superblock TO Private Data
#define SUPERBLOCK_TO_PRIVATE(super) ((struct base0fs_sb_info *)(super)->s_fs_info)
#define SUPERBLOCK_TO_PRIVATE_SM(super) ((super)->s_fs_info)
#define vfs2priv SUPERBLOCK_TO_PRIVATE
// Superblock TO lower Superblock
#define SUPERBLOCK_TO_LOWER(super) (SUPERBLOCK_TO_PRIVATE(super)->wsi_sb)
// Dentry TO lower Dentry (and private data --- for the future)
#define DENTRY_TO_PRIVATE_SM(dentry) ((dentry)->d_fsdata)
#define DENTRY_TO_PRIVATE(dentry) ((struct base0fs_dentry_info *)(dentry)->d_fsdata)
#define DENTRY_TO_LOWER(dent) (DENTRY_TO_PRIVATE(dent)->wdi_dentry)
#define DENTRY_TO_LVFSMNT(dent) (DENTRY_TO_PRIVATE(dent)->wdi_mnt)
#define dir2lower DENTRY_TO_LOWER
/* VMArea TO lower VMArea */
#define VMA_TO_LOWER(vma) ((vm_area_t *)((vma)->vm_private_data))

#define sbt(sb) ((sb)->s_type->name)

/* macros to simplify non-SCA code */
#define MALLOC_PAGE_POINTERS(lower_pages, num_lower_pages)
#define MALLOC_PAGEDATA_POINTERS(lower_pages_data, num_lower_pages)
#define FREE_PAGE_POINTERS(lower_pages, num)
#define FREE_PAGEDATA_POINTERS(lower_pages_data, num)
#define FOR_EACH_PAGE
#define CURRENT_LOWER_PAGE lower_page
#define CURRENT_LOWER_PAGEDATA lower_page_data
#define CURRENT_LOWER_PAGEINDEX ((pgoff_t) page->index)



#ifdef HAVE_KMEM_CACHE_T
#define KMEM_CACHE_T kmem_cache_t
#else
#define KMEM_CACHE_T struct kmem_cache
#endif /* HAVE_KMEM_CACHE_T */

#ifdef HAVE_ADDRESS_SPACE_OPS_EXT
#define ADDRESS_SPACE_OPS_T struct address_space_operations_ext
#else
#define ADDRESS_SPACE_OPS_T struct address_space_operations
#endif

#ifdef HAVE_PATH_IN_STRUCT_FILE
#define FILE_TO_DENTRY(f)       (f)->path.dentry
#else
#define FILE_TO_DENTRY(f)       (f)->f_dentry
#endif

/*
 * EXTERNALS:
 */
extern struct file_operations base0fs_main_fops;
extern struct file_operations base0fs_dir_fops;
extern struct inode_operations base0fs_main_iops;
extern struct inode_operations base0fs_dir_iops;
extern struct inode_operations base0fs_symlink_iops;
extern struct super_operations base0fs_sops;
extern struct dentry_operations base0fs_dops;
extern struct vm_operations_struct base0fs_shared_vmops;
extern struct vm_operations_struct base0fs_private_vmops;
extern ADDRESS_SPACE_OPS_T base0fs_aops;
extern KMEM_CACHE_T * base0fs_inode_cachep;

extern int base0fs_interpose(struct dentry *lower_dentry, struct dentry *this_dentry, super_block_t *sb, int flag);
#if defined(FIST_FILTER_DATA) || defined(FIST_FILTER_SCA)
extern page_t *base0fs_get1page(file_t *file, int index);
extern int base0fs_fill_zeros(file_t *file, page_t *page, unsigned from);
#endif /* FIST_FILTER_DATA || FIST_FILTER_SCA */

#define base0fs_lower_dentry(d) __base0fs_lower_dentry(__FILE__,__FUNCTION__,__LINE__,(d))
extern struct dentry *__base0fs_lower_dentry(const char *file, const char *func, int line, struct dentry *this_dentry);
extern ssize_t base0fs_kernel_read(struct file *file, char *buf, size_t count, loff_t *pos);
extern int base0fs_init_inodecache(void);
extern void base0fs_destroy_inodecache(void);




#define copy_inode_size(dst, src) \
    i_size_write(dst, i_size_read((struct inode *) src)); \
    dst->i_blocks = src->i_blocks;

/*
 * Three macros to simplify fixup and restore of nameidata structures
 * XXX: this code may have concurrency problems.  To prevent those
 * completely, we'd have to add a lock field into struct nameidata.
 */
#ifdef NAMEIDATA_USES_STRUCT_PATH
#define NAMEIDATA_TO_DENTRY(_ndp)       (_ndp)->path.dentry
#define NAMEIDATA_TO_VFSMNT(_ndp)       (_ndp)->path.mnt
#else  /* !NAMEIDATA_USES_STRUCT_PATH */
#define NAMEIDATA_TO_DENTRY(_ndp)       (_ndp)->dentry
#define NAMEIDATA_TO_VFSMNT(_ndp)       (_ndp)->mnt
#endif /* NAMEIDATA_USES_STRUCT_PATH */

#define FIST_ND_DECLARATIONS	struct dentry *saved_dentry = 0; \
				struct vfsmount *saved_vfsmount = 0
#define FIST_ND_SAVE_ARGS(this, _lower_dentry, _lower_mount)		   \
                                saved_dentry   = NAMEIDATA_TO_DENTRY(nd);  \
                                saved_vfsmount = NAMEIDATA_TO_VFSMNT(nd);  \
                                NAMEIDATA_TO_DENTRY(nd) = (_lower_dentry); \
                                NAMEIDATA_TO_VFSMNT(nd) = (_lower_mount)
#define FIST_ND_RESTORE_ARGS	NAMEIDATA_TO_DENTRY(nd) = saved_dentry;    \
                                NAMEIDATA_TO_VFSMNT(nd) = saved_vfsmount;


/*
 * If the kernel has been patched to support the AppArmor security module,
 * then vfs_link, vfs_symlink, etc, take additional "struct vfsmount *" args.
 * We don't have an easy way to get the "correct" value for these parameters,
 * so we just pass NULL.  That's good enough for our needs at this time.
 */

#ifdef HAVE_APP_ARMOR_SECURITY
#define VFS_LINK(d1, i1, d2)    vfs_link((d1), 0, (i1), (d2), 0)
#define VFS_MKDIR(i, d, f)      vfs_mkdir((i), (d), 0, (f))
#define VFS_MKNOD(i, d, f, dev) vfs_mknod((i), (d), 0, (f), (dev))
#define VFS_RENAME(i1,d1,i2,d2) vfs_rename((i1), (d1), 0, (i2), (d2), 0)
#define VFS_RMDIR(i, d)         vfs_rmdir((i), (d), 0)
#define VFS_UNLINK(i, d)        vfs_unlink((i), (d), 0)
#else
#define VFS_LINK(d1, i1, d2)    vfs_link((d1), (i1), (d2))
#define VFS_MKDIR(i, d, f)      vfs_mkdir((i), (d), (f))
#define VFS_MKNOD(i, d, f, dev) vfs_mknod((i), (d), (f), (dev))
#define VFS_RENAME(i1,d1,i2,d2) vfs_rename((i1), (d1), (i2), (d2))
#define VFS_RMDIR(i, d)         vfs_rmdir((i), (d))
#define VFS_UNLINK(i, d)        vfs_unlink((i), (d))
#endif

/* 
 * There's a lot of variety in the humble vfs_symlink() API.  If the AppArmor
 * security module patches have been applied, then vfs_symlink takes an extra
 * vfsmount argument, just like the other vfs_* API's.  However, some versions
 * of Linux also have a patch that modifies vfs_symlink() to take an integer
 * "mode" argument.
 */

#ifdef HAVE_APP_ARMOR_SECURITY
#ifdef HAVE_MODE_IN_VFS_SYMLINK
#    define VFS_SYMLINK(i, d, c, m)     vfs_symlink((i), (d), 0, (c), (m))
#  else
#    define VFS_SYMLINK(i, d, c, m)     vfs_symlink((i), (d), 0, (c))
#  endif
#else
#ifdef HAVE_MODE_IN_VFS_SYMLINK
#    define VFS_SYMLINK(i, d, c, m)     vfs_symlink((i), (d), (c), (m))
#  else
#    define VFS_SYMLINK(i, d, c, m)     vfs_symlink((i), (d), (c))
#  endif
#endif

#ifdef HAVE_PATH_IN_D_PATH
#define D_PATH(p, d, m, c, s)   {               \
    struct path _path;                          \
    _path.dentry = (d);                         \
    _path.mnt    = (m);                         \
    (p) = d_path(&_path, (c), (s));             \
    }
#else
#define D_PATH(p, d, m, c, s)   (p) = d_path((d), (m), (c), (s))
#endif

static inline void
fist_copy_attr_atime(inode_t *dest, const inode_t *src)
{
	BUG_ON(!dest);
	BUG_ON(!src);
	dest->i_atime = src->i_atime;
}
static inline void
fist_copy_attr_ctime(inode_t *dest, const inode_t *src)
{
    BUG_ON(!dest);
    BUG_ON(!src);
    dest->i_ctime = src->i_ctime;
}
static inline void
fist_copy_attr_times(inode_t *dest, const inode_t *src)
{
	BUG_ON(!dest);
	BUG_ON(!src);
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
}
static inline void
fist_copy_attr_timesizes(inode_t *dest, const inode_t *src)
{
	BUG_ON(!dest);
	BUG_ON(!src);
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
	copy_inode_size(dest, src);
}
static inline void
fist_copy_attr_all(inode_t *dest, const inode_t *src)
{
	print_entry_location();
	BUG_ON(!dest);
	BUG_ON(!src);
	dest->i_mode = src->i_mode;
	dest->i_nlink = src->i_nlink;
	dest->i_uid = src->i_uid;
	dest->i_gid = src->i_gid;
	dest->i_rdev = src->i_rdev;
	dest->i_atime = src->i_atime;
	dest->i_mtime = src->i_mtime;
	dest->i_ctime = src->i_ctime;
#ifndef HAVE_NO_INODE_I_BLKSIZE
	dest->i_blksize = src->i_blksize;
#endif
	dest->i_blkbits = src->i_blkbits;
	copy_inode_size(dest, src);

	dest->i_flags = src->i_flags;
	print_exit_location();
}

/* auto-generated extern definitions */


#endif /* __KERNEL__ */

/*
 * Definitions for user and kernel code
 */

/* ioctls */


#endif	/* not __BASE0FS_H_ */

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
