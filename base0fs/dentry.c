/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/dentry.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_base0fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "base0fs.h"

/*
 * d_revalidate: check for lower_dentry != NULL
 */

/*
 * THIS IS A BOOLEAN FUNCTION: returns 1 if valid, 0 otherwise.
 */
STATIC int
base0fs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
{
	int err = 1; // default is valid (1); invalid is 0.
	struct dentry *lower_dentry;
	struct vfsmount *lower_mount;
	FIST_ND_DECLARATIONS;

	print_entry_location();

	lower_dentry = base0fs_lower_dentry(dentry);

	if (!lower_dentry 
                || !lower_dentry->d_op 
                || !lower_dentry->d_op->d_revalidate) {
		goto out;
        }

	lower_mount = DENTRY_TO_LVFSMNT(dentry);

        if (!nd) {
            // On some versions of Linux (2.6.9, eg), unlink calls d_revalidate
            // with a NULL nameidata.  In that case there's no ND to preserve.

            err = lower_dentry->d_op->d_revalidate(lower_dentry, nd);
        } else {

            FIST_ND_SAVE_ARGS(dentry, lower_dentry, lower_mount);
            err = lower_dentry->d_op->d_revalidate(lower_dentry, nd);
            FIST_ND_RESTORE_ARGS;
        }

out:
	print_exit_status(err);
	return err;
}


STATIC int
base0fs_d_hash(struct dentry *dentry, qstr_t *name)
{
	int err = 0;
	struct dentry *lower_dentry;

	print_entry_location();
	lower_dentry = base0fs_lower_dentry(dentry);	/* CPW: Moved to after print_entry_location */

	if (!lower_dentry || !lower_dentry->d_op || !lower_dentry->d_op->d_hash)
		goto out;

	err = lower_dentry->d_op->d_hash(lower_dentry, name);

out:
	print_exit_status(err);
	return err;
}


STATIC int
base0fs_d_compare(struct dentry *dentry, qstr_t *a, qstr_t *b)
{
	int err;
	struct dentry *lower_dentry;

	print_entry_location();

	lower_dentry = base0fs_lower_dentry(dentry);	/* CPW: Moved to after print_entry_location */

	if (lower_dentry && lower_dentry->d_op && lower_dentry->d_op->d_compare) {
		// XXX: WRONG: should encode_filename on a&b strings
		err = lower_dentry->d_op->d_compare(lower_dentry, a, b);
	} else {
		err = ((a->len != b->len) || memcmp(a->name, b->name, b->len));
	}

	print_exit_status(err);
	return err;
}


int
base0fs_d_delete(struct dentry *dentry)
{

	struct dentry *lower_dentry = 0;
	int err = 0;

	print_entry_location();
/*
  EZKDBG;

  if (!DENTRY_TO_PRIVATE(dentry)) goto out;

  EZKDBG;

  lower_dentry = DENTRY_TO_LOWER(dentry);

  EZKDBG;

  if (!lower_dentry) goto out;
  fist_dprint(8, "lower_dentry: %p\n", lower_dentry);

  EZKDBG;

  if (!lower_dentry->d_op) goto out;

  EZKDBG;

  if (!lower_dentry->d_op->d_delete) goto out;

  EZKDBG;

  err = lower_dentry->d_op->d_delete(lower_dentry);

  EZKDBG;

  // skip everything else!
  goto out;
*/

        /* dentry can be NULL */
        if (!dentry)
                goto out;

	/* this could be a negative dentry, so check first */
	if (!DENTRY_TO_PRIVATE(dentry)) {
		fist_dprint(6, "dentry without private data: %*s", dentry->d_name.len, dentry->d_name.name);
		//fist_dprint(6, "dentry without private data");
		goto out;
	}

	if (!(lower_dentry = DENTRY_TO_LOWER(dentry))) {
		fist_dprint(6, "dentry without lower_dentry: %*s", dentry->d_name.len, dentry->d_name.name);
		//fist_dprint(6, "dentry without lower_dentry");
		goto out;
	}

	fist_print_dentry("D_DELETE IN", dentry);
        fist_dprint(8, "before lower d_delete: %p, %p, %p\n", lower_dentry, lower_dentry ? lower_dentry->d_op : 0, lower_dentry->d_op ? lower_dentry->d_op->d_delete : 0);
	/* added b/c of changes to dput(): it calls d_drop on us */
	if (lower_dentry && lower_dentry->d_op &&
            lower_dentry->d_op->d_delete) {
                fist_dprint(8, "lower d_delete\n");
                /*
                   XXX: HL: can we just call d_delete? B/c in dput happens
                   much more depending on its outcome...
                */
		err = lower_dentry->d_op->d_delete(lower_dentry);
	}

out:
	//fist_dprint(8, "exit d_delete\n");
	print_exit_status(err);
	return err;
}


void
base0fs_d_release(struct dentry *dentry)
{
	struct dentry *lower_dentry;

	print_entry_location();
	fist_print_dentry("base0fs_d_release IN dentry", dentry);

	/* this could be a null dentry, so check first */
	if (!dentry) {
		fist_dprint(6, "null dentry");
		goto out;
	}
	/* this could be a negative dentry, so check first */
	if (!DENTRY_TO_PRIVATE(dentry)) {
		fist_dprint(6, "dentry without private data: %*s", dentry->d_name.len, dentry->d_name.name);
		goto out;
	}
	lower_dentry = DENTRY_TO_LOWER(dentry);
	fist_print_dentry("base0fs_d_release IN lower_dentry", lower_dentry);
	if (lower_dentry && lower_dentry->d_inode)
		fist_dprint(6, "base0fs_d_release: lower_inode->i_count %d, i_num %lu.\n",
                            atomic_read(&lower_dentry->d_inode->i_count),
                            lower_dentry->d_inode->i_ino);

	/* free private data (base0fs_dentry_info) here */
	mntput(DENTRY_TO_LVFSMNT(dentry));
	KFREE(DENTRY_TO_PRIVATE(dentry));
	//DENTRY_TO_PRIVATE(dentry) = NULL;	/* just to be safe */
	/* decrement lower dentry's counter and free its inode */
	if (lower_dentry) dput(lower_dentry);
out:
	print_exit_location();
}


/*
 * we don't really need base0fs_d_iput, because dentry_iput will call iput() if
 * base0fs_d_iput is not defined. We left this implemented for ease of
 * tracing/debugging.
 */
void
base0fs_d_iput(struct dentry *dentry, inode_t *inode)
{
	print_entry_location();
	iput(inode);
	print_exit_location();
}


struct dentry_operations base0fs_dops = {
	d_revalidate:   base0fs_d_revalidate,
	d_hash:         base0fs_d_hash,
	d_compare:      base0fs_d_compare,
	d_release:      base0fs_d_release,
	d_delete:       base0fs_d_delete,
	//d_delete:       NULL,
	d_iput:     base0fs_d_iput,
};


/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
